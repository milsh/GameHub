<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Snake — Dark Theme (Single Page)</title>
  <style>
    :root{
      --bg:#071018; /* deep navy */
      --panel:#0b1520;
      --muted:#9aa7b2;
      --accent:#39ff14; /* neon green */
      --accent-2:#ff4da6; /* neon pink */
      --glass: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{background:linear-gradient(180deg,var(--bg), #031018);display:flex;align-items:center;justify-content:center;color:var(--muted)}
    .wrap{width:760px;max-width:95vw;padding:18px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);box-shadow:0 6px 30px rgba(2,6,23,0.6);display:grid;grid-template-columns:1fr 260px;gap:16px}
    header{grid-column:1/-1;display:flex;align-items:center;justify-content:space-between}
    h1{color:white;font-size:18px;margin:0}
    .meta{color:var(--muted);font-size:13px}
    .game-panel{background:var(--panel);padding:12px;border-radius:10px;display:flex;flex-direction:column;align-items:center}
    canvas{background:linear-gradient(180deg, rgba(3,8,15,0.6), rgba(6,12,20,0.8));border-radius:8px;box-shadow:inset 0 0 30px rgba(0,0,0,0.6), 0 6px 24px rgba(2,6,23,0.6)}
    .sidebar{padding:12px;background:var(--glass);border-radius:10px;display:flex;flex-direction:column;gap:10px}
    .score{background:transparent;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
    .big{font-size:28px;color:var(--accent);font-weight:700;letter-spacing:1px}
    .label{font-size:12px;color:var(--muted)}
    .btn{padding:8px 10px;background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);border-radius:8px;cursor:pointer}
    .hint{font-size:12px;color:var(--muted)}
    footer{grid-column:1/-1;text-align:center;color:var(--muted);font-size:12px;margin-top:6px}
    .small{font-size:12px;color:var(--muted)}
    .neon{color:var(--accent-2);font-weight:600}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Snake — Dark Theme</h1>
        <div class="meta">Arrow keys to control • No obstacles • Walls wrap-around</div>
      </div>
      <div class="meta">High score persists in your browser</div>
    </header>

    <div class="game-panel">
      <canvas id="game" width="600" height="600"></canvas>
      <div style="height:8px"></div>
      <div class="hint">Press <span class="neon">Space</span> to pause / resume — Press <span class="neon">R</span> to restart</div>
    </div>

    <aside class="sidebar">
      <div class="score">
        <div class="label">SCORE</div>
        <div id="score" class="big">0</div>
      </div>

      <div class="score">
        <div class="label">HIGH SCORE</div>
        <div id="highScore" class="big">0</div>
      </div>

      <div style="display:flex;gap:8px">
        <button id="restart" class="btn">Restart (R)</button>
        <button id="pauseBtn" class="btn">Pause</button>
      </div>

      <div style="margin-top:6px" class="small">
        <strong>How to play</strong>
        <p class="small">Guide the snake to eat food to grow. If the head runs into the body, the game ends. The edges wrap around so you can go through walls.</p>
      </div>

      <div class="small">Made with ❤️ — Single HTML file. Resize your window to fit.</div>
    </aside>

    <footer>Have fun! — Let me know if you want speed levels or themes.</footer>
  </div>

  <script>
    // Basic settings
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const grid = 20; // size of one cell in px
    const cols = canvas.width / grid; // 600/20 = 30
    const rows = canvas.height / grid;

    let snake = [{x: Math.floor(cols/2), y: Math.floor(rows/2)}];
    let dir = {x:1, y:0}; // starting direction to the right
    let nextDir = {x:1,y:0};
    let food = null;
    let score = 0;
    const highKey = 'snakeHighScore_v1';
    let highScore = parseInt(localStorage.getItem(highKey) || '0', 10);
    let speed = 8; // moves per second
    let lastTime = 0;
    let accumulated = 0;
    let paused = false;
    let gameOver = false;

    // UI refs
    const scoreEl = document.getElementById('score');
    const highEl = document.getElementById('highScore');
    const pauseBtn = document.getElementById('pauseBtn');
    const restartBtn = document.getElementById('restart');

    highEl.textContent = highScore;

    function placeFood(){
      while(true){
        const x = Math.floor(Math.random()*cols);
        const y = Math.floor(Math.random()*rows);
        if(!snake.some(p => p.x===x && p.y===y)){
          food = {x,y};
          return;
        }
      }
    }

    function reset(){
      snake = [{x: Math.floor(cols/2), y: Math.floor(rows/2)}];
      dir = {x:1,y:0};
      nextDir = {x:1,y:0};
      score = 0;
      speed = 8;
      gameOver = false;
      paused = false;
      placeFood();
      updateUI();
    }

    function updateUI(){
      scoreEl.textContent = score;
      highEl.textContent = highScore;
      pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    }

    function step(){
      // apply nextDir but disallow immediate reverse
      if((nextDir.x !== -dir.x || nextDir.y !== -dir.y) || snake.length === 1){
        dir = nextDir;
      }

      const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

      // wrap-around (move through walls)
      head.x = (head.x + cols) % cols;
      head.y = (head.y + rows) % rows;

      // collision with self -> game over
      if(snake.some(s => s.x === head.x && s.y === head.y)){
        gameOver = true;
        if(score > highScore){
          highScore = score;
          localStorage.setItem(highKey, String(highScore));
        }
        updateUI();
        return;
      }

      snake.unshift(head);

      // eat food?
      if(food && head.x === food.x && head.y === food.y){
        score += 1;
        // small speed increase every 5 points
        if(score % 5 === 0) speed += 0.8;
        placeFood();
      } else {
        snake.pop(); // move forward
      }

      updateUI();
    }

    function draw(){
      // background
      ctx.fillStyle = '#031418';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // subtle grid (optional)
      ctx.strokeStyle = 'rgba(255,255,255,0.02)';
      ctx.lineWidth = 1;
      for(let i=0;i<=cols;i++){
        ctx.beginPath();ctx.moveTo(i*grid,0);ctx.lineTo(i*grid,canvas.height);ctx.stroke();
      }
      for(let j=0;j<=rows;j++){
        ctx.beginPath();ctx.moveTo(0,j*grid);ctx.lineTo(canvas.width,j*grid);ctx.stroke();
      }

      // draw food
      if(food){
        drawCell(food.x, food.y, '#ff4da6');
        // glow
        ctx.fillStyle = 'rgba(255,77,166,0.08)';
        ctx.fillRect(food.x*grid-6, food.y*grid-6, grid+12, grid+12);
      }

      // draw snake
      for(let i=snake.length-1;i>=0;i--){
        const p = snake[i];
        const t = i===0 ? 1 : (1 - i/snake.length*0.6);
        const shade = i===0 ? '#39ff14' : `rgba(57,255,20,${0.6 - i/snake.length*0.5})`;
        drawCell(p.x,p.y, shade, i===0);
      }

      // game over overlay
      if(gameOver){
        ctx.fillStyle = 'rgba(2,6,12,0.6)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#fff';
        ctx.font = '36px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Game Over', canvas.width/2, canvas.height/2 - 10);
        ctx.font = '16px system-ui';
        ctx.fillText('Press R to restart', canvas.width/2, canvas.height/2 + 24);
      }
    }

    function drawCell(x,y,fill, head=false){
      const px = x*grid;
      const py = y*grid;
      // base
      ctx.fillStyle = fill;
      const r = 6;
      // rounded rectangle
      roundRect(ctx, px+1, py+1, grid-2, grid-2, 6, true, false);
      if(head){
        // eyes
        ctx.fillStyle = '#001200';
        const eyeR = 3;
        const ox = dir.x === 0 ? 6 : (dir.x > 0 ? 10 : 4);
        const oy = dir.y === 0 ? 6 : (dir.y > 0 ? 10 : 4);
        ctx.beginPath(); ctx.arc(px+ox, py+oy, eyeR, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(px+grid-ox, py+grid-oy, eyeR, 0, Math.PI*2); ctx.fill();
      }
    }

    // helper for rounded rect
    function roundRect(ctx, x, y, w, h, r, fill, stroke){
      if (w < 2 * r) r = w / 2;
      if (h < 2 * r) r = h / 2;
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y,   x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x,   y+h, r);
      ctx.arcTo(x,   y+h, x,   y,   r);
      ctx.arcTo(x,   y,   x+w, y,   r);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    function loop(timestamp){
      if(!lastTime) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;
      if(!paused && !gameOver){
        accumulated += dt;
        const interval = 1 / speed;
        while(accumulated >= interval){
          step();
          accumulated -= interval;
        }
      }
      draw();
      requestAnimationFrame(loop);
    }

    // input
    window.addEventListener('keydown', e => {
      if(gameOver && (e.key === 'r' || e.key === 'R')){
        reset();
        return;
      }
      if(e.key === ' '){ // space - pause
        paused = !paused;
        updateUI();
        return;
      }
      if(e.key === 'r' || e.key === 'R'){
        reset();
        return;
      }

      switch(e.key){
        case 'ArrowUp': nextDir = {x:0,y:-1}; break;
        case 'ArrowDown': nextDir = {x:0,y:1}; break;
        case 'ArrowLeft': nextDir = {x:-1,y:0}; break;
        case 'ArrowRight': nextDir = {x:1,y:0}; break;
      }
    });

    pauseBtn.addEventListener('click', ()=>{ paused = !paused; updateUI(); });
    restartBtn.addEventListener('click', ()=>{ reset(); });

    // initialize
    placeFood();
    updateUI();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
